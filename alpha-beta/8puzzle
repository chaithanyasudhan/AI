import math

def alpha_beta_pruning(state, depth, alpha, beta, maximizing_player):
    # Base case: leaf node or maximum depth reached
    if depth == 0 or is_goal_state(state):
        return heuristic_value(state)

    if maximizing_player:
        max_eval = -math.inf
        for child_state in get_possible_moves(state):
            eval = alpha_beta_pruning(child_state, depth - 1, alpha, beta, False)
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta <= alpha:
                break  # Beta cutoff
        return max_eval
    else:  # Minimizing player
        min_eval = math.inf
        for child_state in get_possible_moves(state):
            eval = alpha_beta_pruning(child_state, depth - 1, alpha, beta, True)
            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta <= alpha:
                break  # Alpha cutoff
        return min_eval

def is_goal_state(state):
    """Checks if the current state is the solved 8-puzzle."""
    # Assuming the goal state is a flattened list [1, 2, 3, 4, 5, 6, 7, 8, 0]
    return state == [1, 2, 3, 4, 5, 6, 7, 8, 0]

def heuristic_value(state):
    """Calculates the Manhattan distance heuristic for the 8-puzzle."""
    goal_state = {
        1: (0, 0), 2: (0, 1), 3: (0, 2),
        4: (1, 0), 5: (1, 1), 6: (1, 2),
        7: (2, 0), 8: (2, 1), 0: (2, 2)
    }
    manhattan_distance = 0
    for i in range(3):
        for j in range(3):
            tile = state[i * 3 + j]
            if tile != 0:
                goal_pos = goal_state[tile]
                manhattan_distance += abs(i - goal_pos[0]) + abs(j - goal_pos[1])
    return manhattan_distance

def get_possible_moves(state):
    """Returns a list of all possible next states from the current state."""
    possible_moves = []
    zero_index = state.index(0)
    zero_row, zero_col = divmod(zero_index, 3)

    # Define possible movements (up, down, left, right)
    movements = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    for move_row, move_col in movements:
        new_row, new_col = zero_row + move_row, zero_col + move_col

        # Check if the new position is within the board boundaries
        if 0 <= new_row < 3 and 0 <= new_col < 3:
            new_state = list(state)  # Create a mutable copy of the state
            swap_index = new_row * 3 + new_col
            # Swap the blank tile with the tile at the new position
            new_state[zero_index], new_state[swap_index] = new_state[swap_index], new_state[zero_index]
            possible_moves.append(new_state)

    return possible_moves
initial_state = [1, 2, 0, 3, 4, 5, 6, 7, 8]
initial_depth = 5

print(f"Initial State: {initial_state}")
print(f"Initial Depth: {initial_depth}")
best_value = alpha_beta_pruning(initial_state, initial_depth, -math.inf, math.inf, True)
print(f"Best value found: {best_value}")
print(f"The result of the alpha-beta pruning (best value from the initial state) is: {best_value}")
